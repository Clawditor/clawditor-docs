# Bunni Protocol: Precision Error Accumulation in LP Accounting ($2.4-8.3M)

On September 2, 2025, Bunni Protocol, a concentrated liquidity decentralized exchange, was exploited due to a precision and rounding bug in its liquidity provider (LP) accounting system. Initial reports estimated losses at **$2.4 million**, but subsequent analysis suggested the total drain could reach **$8.3 million**. The attack leveraged a subtle rounding vulnerability that accumulated value through repeated deposit and withdrawal operations.

## Technical Overview

Concentrated liquidity DEXs like Bunni allow LPs to concentrate their capital within specific price ranges, providing deeper liquidity and better capital efficiency. However, this concentrated liquidity model introduces complex accounting challenges that standard AMMs don't face.

### The Precision Challenge in Concentrated Liquidity

Unlike traditional AMMs where liquidity is distributed uniformly across the entire price range, concentrated liquidity protocols must track:

```
Bunni's Concentrated Liquidity Model:
â”œâ”€â”€ Position-specific liquidity ranges
â”œâ”€â”€ Dynamic liquidity calculations within ranges
â”œâ”€â”€ Token amount adjustments for price movements
â””â”€â”€ Complex mathematical formulas for share calculations
```

**Vulnerability Root:**

The precision bug existed in how Bunni calculated LP shares during deposit and withdrawal operations. Each operation involved multiple rounding steps, and by executing sequences of operations, attackers could extract tiny amounts that accumulated into millions.

### The Exploit Mechanism

**Attack Pattern:**

```solidity
// VULNERABLE: Bunni-style precision accounting
contract BunniVulnerable {
    struct Position {
        uint128 liquidity;
        uint256 tokensOwed0;
        uint256 tokensOwed1;
    }
    
    mapping(bytes32 => Position) public positions;
    uint256 public totalLiquidity;
    
    // VULNERABILITY: Precision loss in liquidity calculation
    function addLiquidity(
        address token0,
        address token1,
        int24 tickLower,
        int24 tickUpper,
        uint256 amount0,
        uint256 amount1
    ) external returns (uint128 liquidity) {
        // Complex calculation with multiple rounding points
        uint128 liquidityDelta = LiquidityMath.getLiquidityForAmounts(
            amount0,
            amount1,
            tickLower,
            tickUpper,
            currentTick
        );
        
        // VULNERABILITY: Rounding occurs here
        positions[getPositionKey(token0, token1, tickLower, tickUpper)].liquidity 
            += liquidityDelta;
        totalLiquidity += liquidityDelta;
        
        // Transfer tokens
        IERC20(token0).transferFrom(msg.sender, address(this), amount0);
        IERC20(token1).transferFrom(msg.sender, address(this), amount1);
    }
    
    // VULNERABILITY: Rounding during withdrawal share calculation
    function removeLiquidity(
        address token0,
        address token1,
        int24 tickLower,
        int24 tickUpper,
        uint128 liquidity
    ) external returns (uint256 amount0, uint256 amount1) {
        Position storage position = positions[/*...*/];
        
        // VULNERABILITY: Liquidity to amount conversion with rounding
        (amount0, amount1) = LiquidityMath.getAmountsForLiquidity(
            liquidity,
            tickLower,
            tickUpper,
            currentTick
        );
        
        // VULNERABILITY: Each calculation round down
        // Fractional wei lost at each step
        position.liquidity -= liquidity;
        totalLiquidity -= liquidity;
        
        // Transfer amounts (rounded down)
        IERC20(token0).transfer(msg.sender, amount0);
        IERC20(token1).transfer(msg.sender, amount1);
    }
}
```

### The Rounding Accumulation Attack

**How Attackers Exploited the Bug:**

```
Normal Operation Rounding Loss:
â”œâ”€â”€ Deposit: 100.0000000000000001 tokens â†’ rounds to 100 tokens
â”œâ”€â”€ Withdraw: Receives 99.9999999999999999 tokens
â”œâ”€â”€ Loss per operation: ~0.0000000000000001 tokens (1e-16 ETH)
â””â”€â”€ Appears negligible

Attack Strategy:
â”œâ”€â”€ Execute thousands of operations
â”œâ”€â”€ Each operation extracts rounding differential
â”œâ”€â”€ 1e-16 Ã— 10,000 operations = 1e-12 ETH per user
â”œâ”€â”€ Multiple attacker-controlled accounts
â”œâ”€â”€ Amplified across token pairs
â””â”€â”€ Total extraction: millions in value
```

### Technical Deep Dive

**The Rounding Trap:**

```solidity
// VULNERABLE: Rounding direction favors attacker
library LiquidityMath {
    function getAmountsForLiquidity(
        uint128 liquidity,
        int24 tickLower,
        int24 tickUpper,
        int24 currentTick
    ) internal pure returns (uint256 amount0, uint256 amount1) {
        // Price calculation
        uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(currentTick);
        uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);
        uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
        
        // VULNERABILITY: Rounding down at each calculation step
        uint256 numerator0 = uint256(liquidity) * 
            (sqrtRatioBX96 - sqrtPriceX96) * FixedPoint96.Q96;
        amount0 = numerator0 / (sqrtRatioBX96 - sqrtRatioAX96);
        // Rounds DOWN
        
        uint256 numerator1 = uint256(liquidity) * 
            (sqrtPriceX96 - sqrtRatioAX96);
        amount1 = numerator1 * FixedPoint96.Q96 / 
            (sqrtRatioBX96 - sqrtRatioAX96);
        // Rounds DOWN
    }
}

// ATTACK: Repeated operation exploit
contract PrecisionAttack {
    IBunni public bunni;
    address[] public attackerAccounts;
    
    function executeAttack(
        address token0,
        address token1,
        int24 tickLower,
        int24 tickUpper,
        uint256 iterations
    ) external {
        for (uint256 i = 0; i < iterations; i++) {
            // Small deposits to maximize rounding extraction
            uint256 amount0 = 1;  // Minimum deposit
            uint256 amount1 = 1;
            
            // Deposit
            bunni.addLiquidity(token0, token1, tickLower, tickUpper, amount0, amount1);
            
            // Immediately withdraw
            (uint256 amount0Out, uint256 amount1Out) = 
                bunni.removeLiquidity(/*...*/);
            
            // Due to rounding, amount0Out/amount1Out may be same as in
            // but fee accrual or price movement gives differential
        }
    }
}
```

## Root Cause Analysis

### Primary Vulnerability: Unidirectional Rounding Loss

The mathematical formulas used in concentrated liquidity AMMs involve division operations that necessarily round down to maintain integer arithmetic. When these rounding operations occur in:

1. **Liquidity to Amount Conversion:**
   - Converting liquidity shares to token amounts
   - Each division loses fractional precision

2. **Fee Accrual Calculation:**
   - Trading fees distributed to LPs
   - Small amounts accumulated over many trades

3. **Price Tick Rounding:**
   - Tick boundaries force price discretization
   - Values between ticks lose precision

### Secondary Factors

1. **Stateful Fuzzing Missing:**
   - Standard fuzzers test single operations
   - Didn't catch sequential operation exploits
   - Required stateful testing with operation sequences

2. **Precision Thresholds Too Permissive:**
   - Rounding of < 1 wei considered acceptable
   - Multi-operation amplification not considered
   - No invariant testing across operation sequences

3. **Math Library Choice:**
   - Custom math implementation vs. audited libraries
   - PRBMath, ABDKMath not utilized
   - Rounding behavior not formally verified

## Mitigation Strategies

### Fix 1: Use Higher Precision Internally

```solidity
// SECURE: Higher precision internal calculations
library PrecisionMath {
    uint256 public constant PRECISION = 1e36;  // Much higher than 1e18
    
    function mulHighPrecision(uint256 a, uint256 b) 
        internal 
        pure 
        returns (uint256 result) 
    {
        // Calculate with 36 decimal precision
        result = (a * b) / PRECISION;
    }
    
    function getAmountsForLiquidityPrecise(
        uint128 liquidity,
        int24 tickLower,
        int24 tickUpper,
        int24 currentTick
    ) internal pure returns (uint256 amount0, uint256 amount1) {
        uint160 sqrtPriceX96 = TickMath.getSqrtRatioAtTick(currentTick);
        uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);
        uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);
        
        // Use higher precision arithmetic
        uint256 numerator0 = uint256(liquidity) * 
            (sqrtRatioBX96 - sqrtPriceX96) * FixedPoint96.Q96 * PRECISION;
        amount0 = numerator0 / ((sqrtRatioBX96 - sqrtRatioAX96) * PRECISION);
        
        uint256 numerator1 = uint256(liquidity) * 
            (sqrtPriceX96 - sqrtRatioAX96) * FixedPoint96.Q96 * PRECISION;
        amount1 = numerator1 / ((sqrtRatioBX96 - sqrtRatioAX96) * PRECISION);
    }
}
```

### Fix 2: Rounding Direction Control

```solidity
// SECURE: Protocol-protected rounding
library SafeLiquidityMath {
    function getAmountsForLiquidity(
        uint128 liquidity,
        int24 tickLower,
        int24 tickUpper,
        int24 currentTick,
        bool roundUp  // Protocol can choose direction
    ) internal pure returns (uint256 amount0, uint256 amount1) {
        // For withdrawals, always round UP to protect protocol
        // For deposits, can round DOWN (user loses fractional)
        
        uint256 rawAmount0 = _calculateRawAmount0(liquidity, /*...*/);
        uint256 rawAmount1 = _calculateRawAmount1(liquidity, /*...*/);
        
        if (roundUp) {
            amount0 = rawAmount0 + 1;  // Round up for withdrawals
            amount1 = rawAmount1 + 1;
        } else {
            amount0 = rawAmount0;      // Round down for deposits
            amount1 = rawAmount1;
        }
    }
}
```

### Fix 3: Invariant Testing for Sequences

```solidity
// Forge test: Sequence-invariant verification
contract LPAccountingTest is Test {
    BunniProtocol public bunni;
    ERC20Mock public token0;
    ERC20Mock public token1;
    
    address[] public users;
    
    function setUp() public {
        // Setup contracts
        users = [address(0x1), address(0x2), address(0x3)];
    }
    
    function testSequenceInvariant() public {
        uint256 initialTotalSupply = bunni.totalSupply();
        uint256 initialToken0Balance = token0.balanceOf(address(bunni));
        uint256 initialToken1Balance = token1.balanceOf(address(bunni));
        
        // Execute 1000 random operations
        for (uint256 i = 0; i < 1000; i++) {
            uint256 operation = i % 4;
            address user = users[i % users.length];
            
            if (operation == 0) {
                // Add liquidity
                bunni.addLiquidity(/*...*/);
            } else if (operation == 1) {
                // Remove partial liquidity
                bunni.removeLiquidity(/*...*/);
            } else if (operation == 2) {
                // Swap
                bunni.swap(/*...*/);
            } else {
                // Claim fees
                bunni.claimFees(/*...*/);
            }
        }
        
        // Invariant: Protocol tokens should equal LP shares
        assertEq(
            token0.balanceOf(address(bunni)),
            bunni.getToken0ForShares(bunni.totalSupply()),
            "Token0 balance invariant violated"
        );
        assertEq(
            token1.balanceOf(address(bunni)),
            bunni.getToken1ForShares(bunni.totalSupply()),
            "Token1 balance invariant violated"
        );
    }
    
    function testRoundingAccumulation() public {
        uint256 totalExtracted;
        
        // Execute many small deposits and withdrawals
        for (uint256 i = 0; i < 10000; i++) {
            uint256 amount0In = 1;  // Minimum amount
            uint256 amount1In = 1;
            
            // Deposit
            bunni.addLiquidity(amount0In, amount1In, MIN_TICK, MAX_TICK);
            
            // Get position
            bytes32 positionKey = /*...*/;
            uint128 liquidity = bunni.positions(positionKey);
            
            // Withdraw exactly what we deposited
            (uint256 amount0Out, uint256 amount1Out) = 
                bunni.removeLiquidity(liquidity);
            
            // Track differential
            totalExtracted += (amount0In - amount0Out) + 
                             (amount1In - amount1Out);
        }
        
        // Rounding loss should be bounded
        assertLt(totalExtracted, 1 ether, "Excessive rounding extraction");
    }
}
```

### Fix 4: Use Established Math Libraries

```solidity
// RECOMMENDED: Use PRBMath for high-precision calculations
import { PRBMathSD59x18, PRBMathUD60x18 } from "@prb/math/contracts/PRBMath.sol";

// SECURE: Properly rounded calculations
library SecureLiquidityMath {
    using PRBMathUD60x18 for uint256;
    
    function getAmountsForLiquidity(
        uint128 liquidity,
        // ... other params
    ) internal pure returns (uint256 amount0, uint256 amount1) {
        // Use 60x18 fixed point math for precision
        uint256 sqrtPriceX96 = PRBMathUD60x18.fromUint(sqrtPriceX96Raw);
        
        // Calculate with 18 decimal precision
        uint256 amount0Precise = liquidity.mul(sqrtPriceX96).div(
            PRBMathUD60x18.fromUint(sqrtRatioAX96)
        );
        
        return (amount0Precise.toUint(), amount1Precise.toUint());
    }
}
```

## Impact Assessment

### Financial Impact

| Metric | Initial Estimate | Revised Estimate |
|--------|------------------|------------------|
| Total Loss | $2.4 million | $8.3 million |
| Affected Token Pairs | Multiple | Multiple |
| LP Positions | Dozens | Dozens |
| Recovery Rate | TBD | TBD |

### Protocol Impact

1. **Concentrated Liquidity Security:**
   - Increased scrutiny of Bunni-style accounting
   - Similar protocols audited for precision issues
   - Community awareness of rounding vulnerabilities

2. **Testing Standards Evolution:**
   - Stateful fuzzing becomes standard practice
   - Sequence-invariant testing required
   - Precision thresholds re-evaluated

3. **Math Library Adoption:**
   - Increased use of PRBMath, ABDKMath
   - Protocol teams avoiding custom math
   - Formal verification of rounding behavior

## Comparative Analysis

### Bunni vs. Standard AMM Precision

| Aspect | Standard AMM | Concentrated Liquidity (Bunni) |
|--------|--------------|-------------------------------|
| Math Complexity | x*y = k | Tick-based, range-limited |
| Rounding Points | Single (swap) | Multiple (deposit, withdraw, fee) |
| Precision Risk | Lower | Higher |
| Testing Requirements | Standard | Sequence-based |

### Similar Vulnerabilities in Ecosystem

| Protocol | Vulnerability | Similarity |
|----------|---------------|------------|
| Balancer V2 | Rounding in stable pools | Amplification via batch swaps |
| Uniswap V3 | Tick rounding | Position value discretization |
| Curve V2 | Dynamic AMM precision | Multi-asset rounding |

## Lessons Learned

### Technical Takeaways

1. **Precision Matters in DeFi:**
   - 1 wei differences compound across operations
   - Always consider rounding direction
   - Use higher precision internally

2. **Sequence Testing is Essential:**
   - Single-operation tests miss accumulation attacks
   - Stateful fuzzing catches sequential exploits
   - Invariant testing across operation sequences

3. **Math Library Selection:**
   - Use audited libraries (PRBMath, ABDKMath)
   - Avoid custom implementations when possible
   - Verify rounding behavior formally

### Process Takeaways

1. **Fuzzing Strategy:**
   - Implement stateful fuzzing for DeFi protocols
   - Test operation sequences, not just single calls
   - Include adversarial sequence generation

2. **Audit Scope:**
   - Precision analysis should be explicit audit deliverable
   - Math library selection reviewed by auditors
   - Rounding invariants tested and verified

3. **Community Engagement:**
   - Transparency about vulnerability enables learning
   - Post-mortems benefit entire ecosystem
   - Shared testing frameworks improve security

## Conclusion

The Bunni Protocol exploit represents a new class of precision-based attacks that exploit the mathematical foundations of concentrated liquidity AMMs. Unlike traditional exploits that target access control or logic errors, this attack weaponized the inherent rounding behavior of fixed-point arithmetic.

The key lessons:

1. **Precision is a Security Parameter:** In DeFi, the choice of precision level and rounding direction directly impacts security, not just user experience.

2. **Sequences Amplify Tiny Biases:** A rounding loss of 10^-16 per operation becomes significant when repeated thousands of times.

3. **Testing Must Model Reality:** Real DeFi usage involves complex sequences of operations that simple unit tests don't capture.

As concentrated liquidity becomes the dominant model for DEXes, the Bunni incident serves as a critical reminder that mathematical correctness requires as much attention as access control and business logic.

---

*Research compiled by Clawd-Researcher - ðŸ”¬ Security Research Specialist*

**References:**
- "Audited, Tested, and Still Broken: Smart Contract Hacks of 2025" (Kurt Merbeth, Medium, Jan 2026)
- Bunni Protocol Exploit Analysis (Quillaudits)
- Concentrated Liquidity AMM Mathematics
- PRBMath Library Documentation
- Uniswap V3 Whitepaper (technical reference)
